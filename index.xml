<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>minu前端学习记录</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on minu前端学习记录</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 20 Aug 2017 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>http://localhost:1313/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;
&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS重难点笔记</title>
      <link>http://localhost:1313/post/js%E9%87%8D%E9%9A%BE%E7%82%B9%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 29 Apr 2020 00:06:01 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E9%87%8D%E9%9A%BE%E7%82%B9%E7%AC%94%E8%AE%B0/</guid>
      
        <description>&lt;h2 id=&#34;闭包&#34;&gt;闭包&lt;/h2&gt;
&lt;h3 id=&#34;什么是闭包&#34;&gt;什么是闭包&lt;/h3&gt;
&lt;p&gt;在嵌套函数中，子函数访问了父函数的变量就形成了闭包&lt;br&gt;
闭包应该就是指子函数与父函数变量之间引用关系，只要函数对变量的引用还在，该变量就不会被回收，即使父函数已执行完毕&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let addOne = (() =&amp;gt; {
    let a = 0
    return () =&amp;gt; {console.log(++a)}
})()
addOne()    // 1
addOne()    // 2
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;闭包的用途&#34;&gt;闭包的用途&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使得变量不会被回收，比如计数器、缓存&lt;/li&gt;
&lt;li&gt;函数外部可以访问和修改函数内部变量，实现封装&lt;/li&gt;
&lt;li&gt;通过返回的函数/对象作为对外接口，模拟一般面向对象语言中“类”的私有属性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;闭包的缺点&#34;&gt;闭包的缺点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;函数的变量会一直保存在内存中，滥用闭包会耗费内存&lt;/li&gt;
&lt;li&gt;函数外部能够轻易改变内部的变量&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;call-apply-bind&#34;&gt;call apply bind&lt;/h2&gt;
&lt;h3 id=&#34;call&#34;&gt;call&lt;/h3&gt;
&lt;p&gt;call可以在调用函数的时候，手动指定this，&lt;code&gt;fn.call(this, arg1, arg2, ...)&lt;/code&gt;&lt;br&gt;
可以用来实现继承&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function People(name, age) {
    this.name = name
    this.age =age
}
function Student(name, age, teacher) {
    People.call(this, name, age)
    this.teacher = teacher
}
let minu = new Student(&amp;quot;minu&amp;quot;, 18, &amp;quot;frankfang&amp;quot;)
console.log(minu)   //  {&amp;quot;name&amp;quot;: &amp;quot;minu&amp;quot;, &amp;quot;age&amp;quot;: 18, &amp;quot;teacher&amp;quot;: &amp;quot;frankfang&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;apply&#34;&gt;apply&lt;/h3&gt;
&lt;p&gt;apply() 的语法和作用 与 call() 类似，唯一的区别是 call()接受的是一个参数列表，apply()接受的是一个参数的数组（或者伪数组）
&lt;code&gt;apply(this, [arg1, arg2, ...])&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;bind&#34;&gt;bind&lt;/h3&gt;
&lt;p&gt;在创建函数的时候调用bind()，函数的this被指定为bind()的第一个参数，不论怎么调用，this不变；也可以指定函数的初始参数
&lt;code&gt;let newFn = fn.bind(this, arg1, arg2, ...)&lt;/code&gt;
用法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在创建函数的时候，this绑定为原始对象&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let module = {
    x:81,
    getX(){
        console.log(this.x)
    }
}
let boundGetX = module.getX.bind(module)
boundGetX()    // 81
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;指定初始参数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function printArguments() {
    console.log(arguments)
}
let defaultArg1 = printArguments.bind(null, 666)
defaultArg1(1, 2, 3)    // [666, 1, 2, 3, length...]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;http状态码&#34;&gt;http状态码&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;100  Continue，临时响应，内容正常可行，客户端应该继续发送请求&lt;/li&gt;
&lt;li&gt;200  OK， 响应成功&lt;/li&gt;
&lt;li&gt;201  Create， 请求已经成功，并因此创建一个新的资源。这通常是在POST请求，或者是某些PUT请求之后返回的响应。&lt;/li&gt;
&lt;li&gt;202  Accepted， 服务器已收到请求，但未响应。&lt;/li&gt;
&lt;li&gt;301 Moved Permanently，所请求的URI资源路径已经改变，新的URL会在响应的Location:头字段里找到。&lt;/li&gt;
&lt;li&gt;400 Bad Request， 请求有误&lt;/li&gt;
&lt;li&gt;401 Unauthorized， 当前请求需要用户验证&lt;/li&gt;
&lt;li&gt;404 Not Found，请求资源找不到&lt;/li&gt;
&lt;li&gt;500 Internal Server Error，服务器遇到了不知道如何处理的情况&lt;/li&gt;
&lt;li&gt;502 Bad Gateway，服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数组去重&#34;&gt;数组去重&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;let newArr = Array.from(new Set([1,5,2,3,4,2,3,1,3,4]))
console.log(newArr)
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1,5,2,3,4,2,3,1,3,4]
let newArr = []
arr.forEach((item) =&amp;gt; {
    if (newArr.indexOf(item) &amp;lt; 0) {
        newArr.push(item)
    }
})
console.log(newArr)
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;Map对象的key是唯一的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1,5,2,3,4,2,3,1,3,4]
let map = new Map()
arr.forEach((item) =&amp;gt; {
    map.set(item)
})
let newArr = []
for (let key of map.keys()) {
    newArr.push(key)
}
console.log(newArr)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;事件相关&#34;&gt;事件相关&lt;/h2&gt;
&lt;h3 id=&#34;事件委托&#34;&gt;事件委托&lt;/h3&gt;
&lt;p&gt;事件委托利用了事件冒泡的特性，将元素本身的事件监听 委托给父元素，可以通过event.target来查看事件是从哪个子元素冒上来的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ul.onclick = (e) =&amp;gt; {
    e.target.style.display = &amp;quot;none&amp;quot; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;阻止默认动作&#34;&gt;阻止默认动作&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;event.preventDefault()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;阻止事件冒泡&#34;&gt;阻止事件冒泡&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;event.stopPropagation()&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;js继承&#34;&gt;JS继承&lt;/h2&gt;
&lt;h3 id=&#34;原型&#34;&gt;原型&lt;/h3&gt;
&lt;p&gt;原型是JS不同对象之间构成关联的核心所在
es6之前，JS的继承主要有两种方法，一是通过指定子类的原型为父类的原型，它的实例就可以通过__proto__访问原型属性；二是子类调用父类构造函数，通过call来指定this&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;构造函数的继承：
function People(name) {
    this.name = name
}
People.prototype.sayHi = function(){console.log(`Hi, I&#39;m ${this.name}`)}

function Student(name, teacher){
    People.call(this, name, teacher)   //继承父类的属性
    this.teacher = teacher
}
Student.prototype = Object.create(People.prototype)   //复制父类prototype达到继承父类原型
Student.prototype.constructor = Student     // 修正子类的构造函数
let s1 = new Student(&amp;quot;minu&amp;quot;, &amp;quot;fang&amp;quot;)
s1.sayHi()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;class&#34;&gt;class&lt;/h3&gt;
&lt;p&gt;js的继承骨子里就是基于原型的，可以认为class是一个prototype的语法糖&lt;br&gt;
class中使用extends来实现继承，通过super()来调用父类的构造方法
语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class People {
    constructor(name){
        this.name = name
    }
    sayHi(){
        console.log(`Hi, I&#39;m ${this.name}`)
    }
}
class Student extends People {
    constructor(name, teacher){
        super(name)
        this.teacher = teacher
    }
}
let s1 = new Student(&amp;quot;minu&amp;quot;, &amp;quot;fang&amp;quot;)
s1.sayHi()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;promise&#34;&gt;Promise&lt;/h2&gt;
&lt;ol start=&#34;0&#34;&gt;
&lt;li&gt;
&lt;p&gt;Promise用于异步任务中，设定结果成功或者失败的不同执行函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;let p1 = new Promise((resolve, reject) =&amp;gt; { })&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.then(onFulfilled, onRejected)&lt;/code&gt; 接受两个函数，都是可选的；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;成功执行onFulfilled，失败执行onRejected；&lt;/p&gt;
&lt;p&gt;失败也可以用.catch(onRejected)；&lt;/p&gt;
&lt;p&gt;then()和catch()都返回一个promise对象，可以链式调用；&lt;/p&gt;
&lt;p&gt;链式调用时，then()里面应该返回一个值，给下一个then()的回调函数用。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Promise.all(iterable) 接受一个可迭代对象，将多个结果合成一个Promise对象；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果所有的结果都是 resolve 那执行resolve的回调，并把每个item的结果以数组形式传给resolve；&lt;/p&gt;
&lt;p&gt;只要一个失败，那就reject， 并把出错的那个item的结果传给reject&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Promise.race(iterable)  也是接受一个数组，那个快就返回那个的结果，不论resolve还是reject&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;嗨呀，好乱啊，: )&lt;/p&gt;
&lt;h2 id=&#34;跨域&#34;&gt;跨域&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;源：协议 + 域名 + 端口 ，两个源一模一样就是同源&lt;/li&gt;
&lt;li&gt;跨域是不同源的页面之间相互访问&lt;/li&gt;
&lt;li&gt;JSONP跨域  是把数据写入js文件当中，然后通过script标签来获取数据，一般是把数据传给回调函数的方式来读取数据&lt;br&gt;
JSONP支持IE，JSONP不能获取http状态码，不支持POST&lt;/li&gt;
&lt;li&gt;CORS 是服务器通过在响应头设置允许访问的白名单来达到跨域，&lt;code&gt;Access-Control-Allow-Origin: xxx.com&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Flex基本用法</title>
      <link>http://localhost:1313/post/flex%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 17 Apr 2020 10:39:51 +0800</pubDate>
      
      <guid>http://localhost:1313/post/flex%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      
        <description>&lt;p&gt;flex布局的两个概念,一个是父容器 container,一个是直接子元素 items&lt;/p&gt;
&lt;h2 id=&#34;父容器的属性&#34;&gt;父容器的属性&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;display: flex&lt;/code&gt;  变成flex布局&lt;br&gt;
&lt;code&gt;flex-direction: row/ column/ row-reverse/ column-reverse&lt;/code&gt;改变items流动方向&lt;br&gt;
&lt;code&gt;flex-wrap: wrap/ wrap-reverse&lt;/code&gt; 换行,默认不换行&lt;/p&gt;
&lt;h3 id=&#34;主轴items的对齐方向-流动方向的轴&#34;&gt;主轴items的对齐方向 (流动方向的轴)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;justify-content: flex-start/ flex-end/ center/ space-between/ space-around/ space-evenly&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;次轴items对齐方向-垂直于主轴&#34;&gt;次轴items对齐方向 (垂直于主轴)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-items: center/ flex-start/ flex-end/ stretch/ baseline&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;items行对齐方向&#34;&gt;items行对齐方向&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-content: flex-start/ flex-end/ stretch/ center/ space-between/ space-around&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;items的属性&#34;&gt;items的属性&lt;/h2&gt;
&lt;p&gt;如果item不设置宽度,默认刚好显示内容的最小宽度&lt;br&gt;
&lt;code&gt;order: 0&lt;/code&gt;默认为零, 从小到大排列&lt;br&gt;
&lt;code&gt;flex-grow: 1&lt;/code&gt;按照份数分配剩余空间&lt;br&gt;
&lt;code&gt;flex-shrink: 0&lt;/code&gt; 当空间缩小的时候, 每个item缩小的比例,大的先缩小, 0 不缩小&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JQuery的基本使用</title>
      <link>http://localhost:1313/post/jquery%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 16 Apr 2020 22:53:12 +0800</pubDate>
      
      <guid>http://localhost:1313/post/jquery%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      
        <description>&lt;h2 id=&#34;jquery-如何获取元素&#34;&gt;jQuery 如何获取元素&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;jQuery获取元素是通过调用DOM原生的&lt;code&gt;querySelectorAll()&lt;/code&gt;，这样就可以用css选择器来获取元素，比如：&lt;br&gt;
&lt;code&gt;$(&#39;input[name=first]&#39;)&lt;/code&gt;  选择name=first的input元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后jQuery还加入了其特有的表达式，包括：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$(&#39;tr: odd&#39;)&lt;/code&gt;   选择表格的奇数行&lt;br&gt;
&lt;code&gt;$(&#39;div: gt(2)&#39;)&lt;/code&gt;    选择所有的div元素，除了前三个&lt;br&gt;
&lt;code&gt;$(&#39;div: animated&#39;)&lt;/code&gt;    选择当前处于动画状态的div元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;jQuery加入了过滤器筛选结果，包括属性过滤、位置过滤、父子兄弟选择等&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$(&#39;div&#39;).has(&#39;p&#39;)&lt;/code&gt;    选择包含p元素的div元素&lt;br&gt;
&lt;code&gt;$(&#39;div&#39;).not(&#39;.myClass&#39;)&lt;/code&gt;   选择class不等于myClass的div元素&lt;br&gt;
&lt;code&gt;$(&#39;div&#39;).filter(&#39;.myClass&#39;)&lt;/code&gt;   选择class等于myClass的div元素&lt;br&gt;
&lt;code&gt;$(&#39;div&#39;).eq(5)&lt;/code&gt;   选择第6个div元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;jQuery选择元素的结果，默认是伪数组的形式存在，默认对结果集的全部元素应用操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;jquery-的链式操作是怎样的&#34;&gt;jQuery 的链式操作是怎样的&lt;/h2&gt;
&lt;p&gt;每次执行函数操作之后, 返回当前对象, 这样可以通过&lt;code&gt;.&lt;/code&gt;继续操作当前对象, 可以将一串操作连在一起。&lt;br&gt;
当操作的元素改变的时候, 返回一个新对象$(newEl)，两个对象操作的元素不会相互污染&lt;br&gt;
同时jQuery还提供了一个.end()方法， 返回上一级结果集&lt;/p&gt;
&lt;h2 id=&#34;jquery-如何创建元素&#34;&gt;jQuery 如何创建元素&lt;/h2&gt;
&lt;p&gt;使用template，template标签是不会被浏览器渲染的，但是它可以把html字符串变成dom节点
字符串放到template标签里之后，再通过template.content获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let container = document.createElement(&amp;quot;template&amp;quot;)
container.innerHTML = &amp;quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;quot;
let new_div = container.content.firstChild
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;jquery-如何移动元素&#34;&gt;jQuery 如何移动元素&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;$(&#39;div&#39;).insertAfter($(&#39;p&#39;))&lt;/code&gt; 把div元素移动到p元素的后面,并返回&lt;code&gt;$(&#39;div)&lt;/code&gt;&lt;br&gt;
&lt;code&gt;$(&#39;p&#39;).after($(&#39;div&#39;))&lt;/code&gt; 效果同上把,把p元素放到div元素的前面, 返回&lt;code&gt;$(&#39;p&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谁调用就返回谁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部, 插入兄弟元素:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;$移动元素.insertAfter($参照元素)&lt;/code&gt; \ &lt;code&gt;$参照元素.after($移动元素)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$p_before.insertBefore($p_after)&lt;/code&gt; \ &lt;code&gt;$p_after.before($p_before)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;内部, 插入子元素:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;$child.appendTo($parent)&lt;/code&gt; \ &lt;code&gt;$parent.append($child)&lt;/code&gt;   在内部的最后插入子元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$child.prependTo($parent)&lt;/code&gt; \ &lt;code&gt;$parent.prepend()&lt;/code&gt;  在内部的前面插入子元素&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;jquery-如何修改元素的属性&#34;&gt;jQuery 如何修改元素的属性&lt;/h2&gt;
&lt;p&gt;jQuery的获取和修改属性是用同一个函数的， 通过判断参数的个数来实现不同的操作&lt;br&gt;
一般不传参数就是读取该属性的值， 默认读取结果集的第一个元素的属性值。（.text()例外，它取出所有元素的text内容）&lt;br&gt;
常用的有： &lt;code&gt;.html() .text() .attr() .width() .height() .val()&lt;/code&gt;&lt;br&gt;
注意改变style使用.css()&lt;br&gt;
&lt;code&gt;$p.css(&amp;quot;color&amp;quot;)&lt;/code&gt; 获取color&lt;br&gt;
&lt;code&gt;$p.css(&amp;quot;color&amp;quot;, &amp;quot;red&amp;quot;)&lt;/code&gt;  设置color&lt;/p&gt;
&lt;p&gt;批量设置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$p.css({
    &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;, 
    &amp;quot;fontSize&amp;quot;: &amp;quot;20px&amp;quot;
})```  &lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>JS对象的基本用法</title>
      <link>http://localhost:1313/post/js%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sat, 04 Apr 2020 23:07:31 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      
        <description>&lt;h2 id=&#34;创建对象&#34;&gt;创建对象&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;let obj = {
     &amp;quot;name&amp;quot;:&amp;quot;minu&amp;quot;,
     age:18
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;let obj = new Object({
     &amp;quot;name&amp;quot;:&amp;quot;minu&amp;quot;, 
     age:18
 })
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;删除对象属性&#34;&gt;删除对象属性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;delete obj.age&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obj.age = undefined&lt;/code&gt; 不能删除属性，只能让其属性值变成undefined&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查看对象属性&#34;&gt;查看对象属性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;obj.name&lt;/code&gt; 或者 &lt;code&gt;obj[&amp;quot;name&amp;quot;]&lt;/code&gt; 查看name的值，&lt;strong&gt;name是字符串&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.keys(obj)&lt;/code&gt; 查看obj的所有key&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.values(obj)&lt;/code&gt; 查看obj的所有值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.entries(obj)&lt;/code&gt; 同时查看键和值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;console.dir(obj)&lt;/code&gt; 查看自身属性和原型属性&lt;/li&gt;
&lt;li&gt;chrome中使用&lt;code&gt;obj.__proto__&lt;/code&gt;或者&lt;code&gt;Object.prototype&lt;/code&gt;查看对象的原型，第一种是chrome写法，第二种是官方写法&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;修改和增加对象属性&#34;&gt;修改和增加对象属性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修改name的值：&lt;br&gt;
&lt;code&gt;obj.name = &amp;quot;new name&amp;quot;&lt;/code&gt;、&lt;code&gt;obj[&amp;quot;name&amp;quot;] = &amp;quot;new name&amp;quot;&lt;/code&gt;、&lt;code&gt;let obj = {name: &amp;quot;new name&amp;quot;}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;批量添加或修改：&lt;br&gt;
&lt;code&gt;Object.assign(obj, {age: 18, gender : &amp;quot;M})&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改原型的属性：
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;obj.toString = &amp;quot;new toString&lt;/code&gt; 只会在obj自身创建同名的toString属性，不会修改原型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object.__proto__.toString = &amp;quot;xxx&amp;quot;&lt;/code&gt;或者&lt;code&gt;Object.prototype.toString = &amp;quot;xxx&amp;quot;&lt;/code&gt;会修改原型的toString方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let obj2 = {};obj.__proto__ = obj2;&lt;/code&gt;
会修改obj.__proto__指向为obj2，obj2.__proto__指向原型，obj.toString依然可以调用根原型的toString方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let obj3 = Object.create(obj2)&lt;/code&gt; 在创建的时候指定原型。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;name-in-obj-和-hasownpropertyname的区别&#34;&gt;&amp;ldquo;name&amp;rdquo; in obj 和 hasOwnProperty(&amp;ldquo;name&amp;rdquo;)的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;name&amp;quot; in obj&lt;/code&gt; 查找范围是自身以及其原型, 其中一个地方有都会返回true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obj.hasOwnProperty(&amp;quot;name&amp;quot;)&lt;/code&gt; 查找范围是对象自身。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;要点&#34;&gt;要点：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对象的键是字符串&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;原型也有原型，是null，&lt;code&gt;Object.prototype.__proto__&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>JS基本语法</title>
      <link>http://localhost:1313/post/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sat, 04 Apr 2020 20:46:22 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      
        <description>&lt;h2 id=&#34;表达式和语句&#34;&gt;表达式和语句&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;表达式一般都会有值，如 &lt;code&gt;2 + 3    //5&lt;/code&gt;， 5就是该语句计算出来的值；&lt;code&gt;console.log(3)  //3&lt;/code&gt;   打印 3 是函数执行的效果，值是函数的返回值 undefined。&lt;/li&gt;
&lt;li&gt;语句可能有值也可能没有，语句一般会改变环境（声明、赋值），如 &lt;code&gt;var a = 1;&lt;/code&gt;，该语句的值为返回值 undefined。&lt;/li&gt;
&lt;li&gt;上面并不绝对，个人理解是表达式会产生一个值，语句是执行一个行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;标识符的规则&#34;&gt;标识符的规则&lt;/h2&gt;
&lt;p&gt;JS中所有可以由我们自主命名的都可以称为标识符，如变量名、函数名，命名的时候要遵守命名规则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由unicode字母、$、_和数字组成，不能以数字开头，中文也是合法标识符&lt;/li&gt;
&lt;li&gt;不能是es中的关键字和保留字&lt;/li&gt;
&lt;li&gt;一般采用驼峰命名法 &lt;code&gt;getImg&lt;/code&gt; &lt;code&gt;myFunc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;if-else-语句&#34;&gt;if else 语句&lt;/h2&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = 5;
if (a%2 === 0) {
    console.log(&amp;quot;a是偶数&amp;quot;)
}
else {
    console.log(&amp;quot;a是奇数&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要点：
如果省略 {}，if只会管到条件之后的第一句。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = 5;
if (a &amp;gt; 10)
    console.log(&amp;quot;a大于10&amp;quot;);
    console.log(&amp;quot;哈哈哈&amp;quot;);

//哈哈哈
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不推荐省略 {}，要简写可用 &lt;code&gt;条件?成立执行语句:不成立执行语句&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;while和for语句&#34;&gt;while和for语句&lt;/h2&gt;
&lt;p&gt;语法：
while(条件){语句} 语句中一般要添加条件的增量，防止死循环&lt;br&gt;
for循环被认为是while循环语法的语法糖。&lt;br&gt;
？ 语法糖？听过不少，但是一直不知道是什么。。。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;语法，for遍历数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr =[];
for (let i = 0, i &amp;lt; arr.length, i++){
    console.log(arr[i]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要点：&lt;/p&gt;
&lt;p&gt;for (var i = 0, ,)里面setTimeout的话，把for循环完之后，再去执行setTimeout的回调函数。用let不会。&lt;/p&gt;
&lt;h2 id=&#34;break和continue&#34;&gt;break和continue&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt;和&lt;code&gt;continue&lt;/code&gt;都是作用于上一级直接父层，break退出整个父层循环，continue退出本次循环流程，开始下一次。&lt;br&gt;
注意：
switch要记得break，当然有时候也不使用break，来达到判断多个条件同时成立的效果。&lt;/p&gt;
&lt;h2 id=&#34;label&#34;&gt;label&lt;/h2&gt;
&lt;p&gt;语法：
&lt;code&gt;label1 : { console.log(&amp;quot;this is a label.&amp;quot;); }&lt;/code&gt;javascript&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;label 与 break、continue配合使用，主要应用在循环结构、多分支结构中，以便跳出内层嵌套体。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要点：&lt;br&gt;
&lt;code&gt;{ foo : 1 }&lt;/code&gt;javascript&lt;br&gt;
在chrome会被认为是对象，在firefox会被认为是标签。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{ foo : 1; }&lt;/code&gt;javascript
在chrome中被认为是标签。&lt;/p&gt;
&lt;h2 id=&#34;js要点&#34;&gt;JS要点：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JS 大小写敏感&lt;/li&gt;
&lt;li&gt;JS中只要不影响断句，多余的空格不会影响执行，一般为了代码可读性，符号前后添加空格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a &amp;amp;&amp;amp; b &amp;amp;&amp;amp; c&lt;/code&gt; 取第一个假值或者最后一个值 c，&lt;code&gt;a || b || c&lt;/code&gt;取第一个真值或者最后一个值 c。&lt;/li&gt;
&lt;li&gt;return不能回车，如果接了回车，JS会自以为是的在后面加&lt;code&gt;;&lt;/code&gt;，返回undefined&lt;/li&gt;
&lt;li&gt;不要滥用注释，注意把坑标注&lt;/li&gt;
&lt;li&gt;JS的精度问题，&lt;code&gt;0.1 + 0.2 !== 0.3&lt;/code&gt;，到底是什么问题，我现在也说不清楚，好像是关系到进制和存储的问题，这里只做个记录。
&lt;blockquote&gt;
&lt;p&gt;对于像0.1这样的数值用二进制表示你就会发现无法整除，最后算下来会是 0.000110011&amp;hellip;.由于存储空间有限，最后计算机会舍弃后面的数值，所以我们最后就只能得到一个近似值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>JavaScript的诞生</title>
      <link>http://localhost:1313/post/javascript%E7%9A%84%E8%AF%9E%E7%94%9F/</link>
      <pubDate>Mon, 30 Mar 2020 19:43:38 +0800</pubDate>
      
      <guid>http://localhost:1313/post/javascript%E7%9A%84%E8%AF%9E%E7%94%9F/</guid>
      
        <description>&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 1994 年底，网景公司发布了 navigator 0.9 版本，迅速占领市场，轰动一时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 但是当时的浏览器只能看，并不能跟访问者交互。网景需一种网页脚本语言，使得浏览器可以与网页互动，当时网景有两个选择，一个是采用现有的语言，一个是发明一种新的语言。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 1995 年 sun 公司正式推出 Java，声称这种语言可以“一次编写，到处运行”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 网景看中了 Java，并和 sun 公司勾搭，允许 Java 以 applet（小程序）的形式在浏览器中运行，还考虑将 Java 作为脚本语言嵌入网页中，但这会使得 html 过于复杂，这时网景内部产生激烈的争论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; 1995 年 4 月，网景招募了 Brendan Eich，为的是把 Scheme 语言嵌入浏览器当中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt; 一个月之后，网景最后决定要发明一种新的脚本语言，并且新语言“看上去与 Java 足够相似”。同月，Brendan Eich 仅花了十天就把新语言的原型设计出来了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.&lt;/strong&gt; 新语言最初被命名为 Mocha，1995 年 9 月改名为 LiveScript，同年 12 月，网景为了蹭 Java 的热度，在新语言将要部署的时候，将其改名为 JavaScript。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.&lt;/strong&gt; JavaScript 推出后大获成功，不久后，微软在 Internet Explorer 3 推出了 JScript，与网景的 JavaScript 双峰对峙。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9.&lt;/strong&gt; 1996 年 11 月，网景向 ECMA 提交语言标准，ECMA 以 JavaScript 语言为基础制定了 ECMAScript 标准规范 ECMA-262&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;，JavaScript 的诞生经历使得它充满妥协与缺陷。&lt;br&gt;
设计者布莱登其实对 Java 并不感兴趣，十天完成原型设计只是为了完成公司的任务，新语言缺少了一些对细节的考虑。&lt;br&gt;
网景为了确立其 JS 的地位，早早向 ECMA 提交标准，相比于 C 语言问世近 20 年才发布国际标准，JS 推出一年半就确立标准，确实显得太过仓促。&lt;br&gt;
但是，随着新标准的发布和借助一些第三方的帮助，只要我们好好遵守代码规范，大部分缺陷都可以回避。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS知识总结</title>
      <link>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 29 Mar 2020 21:05:37 +0800</pubDate>
      
      <guid>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;h2 id=&#34;浏览器的渲染原理&#34;&gt;浏览器的渲染原理&lt;/h2&gt;
&lt;h3 id=&#34;渲染流程&#34;&gt;渲染流程:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;根据 html 生成 DOM 节点树&lt;/li&gt;
&lt;li&gt;根据 CSS 生成 CSSOM&lt;/li&gt;
&lt;li&gt;合并 html 和 CSS，生成待渲染的树&lt;/li&gt;
&lt;li&gt;layout 确定布局，计算大小和位置&lt;/li&gt;
&lt;li&gt;paint 绘制上色、阴影等&lt;/li&gt;
&lt;li&gt;composite 合并图层，根据层叠关系展示画面&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;画面更新流程&#34;&gt;画面更新流程：&lt;/h3&gt;
&lt;p&gt;1、layout =&amp;gt; paint =&amp;gt; composite&lt;/p&gt;
&lt;p&gt;2、paint =&amp;gt; composite&lt;/p&gt;
&lt;p&gt;3、composite&lt;/p&gt;
&lt;p&gt;三个流程，不同属性、不同浏览器有不同，流程越少性能越好，具体查&lt;a href=&#34;https://csstriggers.com/&#34;&gt;csstriggers.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;css-动画的两种做法&#34;&gt;CSS 动画的两种做法&lt;/h2&gt;
&lt;h3 id=&#34;transition&#34;&gt;transition&lt;/h3&gt;
&lt;p&gt;作用是两个关键帧之间添加过渡效果，限制是只能两个关键帧，也可以通过监听中间节点来达到多次变化，但是麻烦。&lt;/p&gt;
&lt;h3 id=&#34;animation&#34;&gt;animation&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;@keyframes&lt;/code&gt;可以设置多个关键帧，还可以定义循环次数，方向，暂停等等，功能强大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学完这课就是把基本的常用动画过了一遍，详细的还要看 MDN 文档，还有就是要多写，记住一些常用的例子以及一些坑。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>浅析URL</title>
      <link>http://localhost:1313/post/%E6%B5%85%E6%9E%90url/</link>
      <pubDate>Thu, 26 Mar 2020 21:13:15 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E6%B5%85%E6%9E%90url/</guid>
      
        <description>&lt;h3 id=&#34;1url的组成&#34;&gt;1、URL的组成&lt;/h3&gt;
&lt;p&gt;uniform resource locator 统一资源定位符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协议：规定了客户端与服务器通讯的协议&lt;/li&gt;
&lt;li&gt;域名或者ip：指定了服务器的网络位置&lt;/li&gt;
&lt;li&gt;端口：指定了服务器提供的哪种服务，默认http为80，https为443&lt;/li&gt;
&lt;li&gt;路径：指定了要访问的资源的存放路径&lt;/li&gt;
&lt;li&gt;查询参数：指定了服务器返回的内容，用于搜索、查询内容，指定页数等等&lt;/li&gt;
&lt;li&gt;锚点：本地页面某区域的定位和跳转，不包含在请求中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2dns&#34;&gt;2、DNS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Domain Name System 域名系统，主要用于域名与 IP 地址的相互转换，以及控制因特网的电子邮件的发送。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nslookup baidu.com&lt;/code&gt; 就可以查询baidu.com对应的ip地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3ipping&#34;&gt;3、IP/ping&lt;/h3&gt;
&lt;p&gt;IP（Internet Protocol）网际互连协议，用来标记设备在网络中的位置。&lt;/p&gt;
&lt;p&gt;ping（Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序。&lt;/p&gt;
&lt;p&gt;ping用于确定本地主机是否能与另一台主机成功交换(发送与接收)数据包，再根据返回的信息，就可以推断TCP/IP参数是否设置正确，以及运行是否正常、网络是否通畅等。&lt;/p&gt;
&lt;p&gt;用法：&lt;code&gt;ping baidu.com&lt;/code&gt; ，注意ping不成功也有可能是服务器拒绝ping&lt;/p&gt;
&lt;h3 id=&#34;4域名&#34;&gt;4、域名&lt;/h3&gt;
&lt;p&gt;Domain Name，域名通过dns映射为ip，这样就可以通过域名访问服务器，比起ip，方便记忆和传播。&lt;/p&gt;
&lt;p&gt;域名分级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶级域名就是一级域名，&lt;code&gt;.com&lt;/code&gt;  &lt;code&gt;.cn&lt;/code&gt;  &lt;code&gt;.org&lt;/code&gt;等，&lt;code&gt;zhihu.com&lt;/code&gt;是二级域名。&lt;/li&gt;
&lt;li&gt;但是，我们习惯上把&lt;code&gt;qq.com&lt;/code&gt;称为一级域名，把&lt;code&gt;pvp.qq.com&lt;/code&gt;称为二级域名。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>HTML常用标签</title>
      <link>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Tue, 17 Mar 2020 22:55:00 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
      
        <description>&lt;h2 id=&#34;a-标签&#34;&gt;a 标签&lt;/h2&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;p&gt;anchor 用于超链接，跳转外部页面，跳转内部锚点（#id），跳转邮箱或电话等（mailto:xx@xx.xx;tel:12345678910）&lt;/p&gt;
&lt;h3 id=&#34;属性&#34;&gt;属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;href&lt;/p&gt;
&lt;p&gt;1、使用无协议写法&lt;code&gt;href = &amp;quot;//google.com&amp;quot;&lt;/code&gt;，协议会继承自当前网页协议。&lt;/p&gt;
&lt;p&gt;2、使用路径的时候，&lt;code&gt;/&lt;/code&gt;指的是 http 开启位置的根目录&lt;/p&gt;
&lt;p&gt;3、使用伪协议&lt;code&gt;href = &amp;quot;javascript:;&lt;/code&gt;屏蔽 a 标签的默认跳转行为，可以用来触发其他操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;target&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;_blank&lt;/code&gt; 新标签打开&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;iframe&lt;/code&gt; 已经很多使用(&lt;code&gt;_top&lt;/code&gt; 在最外层窗口打开，&lt;code&gt;_parent&lt;/code&gt; 在父窗口打开，&lt;code&gt;_self&lt;/code&gt; 在当前窗口打开)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rel&lt;/p&gt;
&lt;p&gt;1、用于指定当前文档与被链接文档之间的关系&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;rel = noopener&lt;/code&gt;：但 a 标签使用&lt;code&gt;target = _blank&lt;/code&gt;时，新标签可以通过&lt;code&gt;window.opener&lt;/code&gt;访问原标签，原标签可能会被改变；使用了&lt;code&gt;rel = noopener&lt;/code&gt;就可以阻止&lt;code&gt;window.opener&lt;/code&gt;，不能进行跨窗口访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;img-标签&#34;&gt;img 标签&lt;/h2&gt;
&lt;p&gt;发出 get 请求，显示一张图片&lt;/p&gt;
&lt;h3 id=&#34;属性-1&#34;&gt;属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;alt&lt;/code&gt; 图片加载失败时显示的文字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;height、width&lt;/code&gt;指定图片宽高，指定其中一个的时候，另一个会按比例自适应，这两个是 img 的属性，不是 CSS，注意区别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt; 图片的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事件&#34;&gt;事件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;onload 图片加载成功的时候触发&lt;/li&gt;
&lt;li&gt;onerror 图片加载失败的时候触发，图片加载失败时，可以用其他图片来代替，以提升用户体验&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;响应式&#34;&gt;响应式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;max-width:100%&lt;/code&gt;最大宽度为窗口的宽度，实现响应式的显示。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;可替换元素&#34;&gt;可替换元素&lt;/h3&gt;
&lt;p&gt;replaced element 是一种外部对象，CSS 只能控制其位置，不能控制其内容。
常见的可替换元素有&lt;code&gt;iframe&lt;/code&gt;、&lt;code&gt;video&lt;/code&gt;、&lt;code&gt;embed&lt;/code&gt;、&lt;code&gt;img&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;table-标签&#34;&gt;table 标签&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;table 只能写三个直接子标签&lt;code&gt;thead&lt;/code&gt;、&lt;code&gt;tbody&lt;/code&gt;、&lt;code&gt;tfoot&lt;/code&gt;，下一级是&lt;code&gt;tr&lt;/code&gt;，再下一级是&lt;code&gt;th&lt;/code&gt;、&lt;code&gt;td&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;做表格应该一行一行写&lt;/li&gt;
&lt;li&gt;表格一般写这两行去除默认的样式：&lt;code&gt;border-collapse:collapse&lt;/code&gt;合并相邻的边框;&lt;code&gt;border-spacing:0&lt;/code&gt;边框的间隔为零。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;table-layout&lt;/code&gt;指定表格行列的大小的算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;感想&#34;&gt;感想&lt;/h3&gt;
&lt;p&gt;标签太多了，要多练习运用才能记得住，不然隔一段时间就会忘记，特别是 input 标签的类型很多，应该每个都写一个实例帮助记忆。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>3月17复习</title>
      <link>http://localhost:1313/post/3.17%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Tue, 17 Mar 2020 21:49:24 +0800</pubDate>
      
      <guid>http://localhost:1313/post/3.17%E5%A4%8D%E4%B9%A0/</guid>
      
        <description>&lt;h3 id=&#34;文件的增删改查&#34;&gt;文件的增删改查&lt;/h3&gt;
&lt;p&gt;1、文件的查看&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 表示用户目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 表示当前目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;..&lt;/code&gt; 表示上级目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt; 代表根目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pwd&lt;/code&gt; 查看当前目录（process word directory 进程目录）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls&lt;/code&gt; 显示当前目录的所有文件（ls 路径）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls -1&lt;/code&gt; 每行显示一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls -a&lt;/code&gt; 显示所有文件，包括隐藏文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls -l&lt;/code&gt; 查看文件的详细信息，还可以写为 &lt;code&gt;ll&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat&lt;/code&gt; 显示文件的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;less&lt;/code&gt; 分页显示文件内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head&lt;/code&gt; 默认显示文件内容的前十行，可以添加参数 &lt;code&gt;-n 8&lt;/code&gt;显示文件的前 8 行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tail&lt;/code&gt; 同理 head 显示内容的后十行
2、文件的增加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touch&lt;/code&gt; 如果文件不存在，新建一个文件；如果文件存在，则刷新文件的最后更新时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo&lt;/code&gt; 向文件写入内容， &lt;code&gt;&amp;gt;&lt;/code&gt; 覆盖写入；&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 追加写入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir&lt;/code&gt; 创建文件夹，如果文件夹存在，则会失败&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;不熟练的知识点&#34;&gt;不熟练的知识点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mv&lt;/code&gt; 除了移动文件，还可以重命名文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ls --help&lt;/code&gt; 查看帮助，其他命令同理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;echo $?&lt;/code&gt; 查看上一个命令命令执行的结果，一般 0 是成功，1 是失败&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bash 中，&lt;code&gt;alt + .&lt;/code&gt; 输入上次输入的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把命令写到一个文件当中，然后&lt;code&gt;sh mybash&lt;/code&gt;就可以指执行 mybash，文件中，还可以使用$1、$2、$3 来传参&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;npm cnpm npx yarn&lt;/code&gt; 都是包管理工具，用来管理 js 的代码库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 git 的步骤，先六条命令配置 git（包括邮箱、用户名、默认编辑器等等），然后 git init 初始化，git add ,git commit, 初次提交绑定远程仓库 git remote origin add xxx；git -u origin master&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git reflog 查看详细记录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git reset &amp;ndash;hard xxx 版本切换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git branch x 创建 x 分支&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git checkout x 切换 x 分支&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git pull 是将远程仓库的改动下载到本地仓库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git merge 合并分支&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ssh-keygen -t rsa -b 4096 就可以在本地创建公钥和私钥，把公钥添加到 github 就可以通过 ssh 访问远程仓库，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Html入门笔记1</title>
      <link>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Sat, 14 Mar 2020 22:54:16 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</guid>
      
        <description>&lt;h3 id=&#34;html-是谁发明的&#34;&gt;html 是谁发明的&lt;/h3&gt;
&lt;p&gt;HTML（Hypertext Marked Language，超文本标记语言）是由 Web 的发明者 Tim Berners-Lee 和同事 Daniel W. Connolly 于 1990 年创立的一种标记语言，它是标准通用化标记语言 SGML 的应用。&lt;/p&gt;
&lt;h3 id=&#34;html-起手式应该写什么&#34;&gt;html 起手式应该写什么&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 文档类型 --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;!-- html标签 --&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;!-- head，页面信息，看不见的内容 --&amp;gt;
  &amp;lt;head lang=&amp;quot;zh-CN&amp;quot;&amp;gt;
    &amp;lt;!-- 字符编码 --&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt;
    &amp;lt;!-- 视口，内容宽度等于设备屏幕宽度，缩放比例为1 --&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot; /&amp;gt;
    &amp;lt;!-- ie浏览器使用最新的渲染模式 --&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;
      网页标题
    &amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;!-- 网页显示内容 --&amp;gt;
  &amp;lt;body&amp;gt;
    内容
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;常用的表示章节的标签&#34;&gt;常用的表示章节的标签&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;h1~h6&lt;/code&gt; 六级标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;section&lt;/code&gt; 章节、部分&lt;/li&gt;
&lt;li&gt;&lt;code&gt;article&lt;/code&gt; 文章&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt; 主要内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aside&lt;/code&gt; 次要内容，侧边栏&lt;/li&gt;
&lt;li&gt;&lt;code&gt;header&lt;/code&gt; 页眉，头部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;footer&lt;/code&gt; 页脚，尾部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nav&lt;/code&gt; 导航栏&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;全局属性&#34;&gt;全局属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt; 类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hidden&lt;/code&gt; 隐藏元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;contenteditable&lt;/code&gt; 内容可编辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;style&lt;/code&gt; 写 css 的属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tabindex&lt;/code&gt; 指定 tab 键选中顺序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;title&lt;/code&gt; 鼠标放上去显示的文本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常用的内容标签&#34;&gt;常用的内容标签&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; 超链接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strong&lt;/code&gt; 重要，内容本身重要&lt;/li&gt;
&lt;li&gt;&lt;code&gt;em&lt;/code&gt; 强调，语气强调&lt;/li&gt;
&lt;li&gt;&lt;code&gt;code&lt;/code&gt; 写代码，默认使用等宽字体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pre&lt;/code&gt; 保留全部空格和回车&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>如何用hugo搭建个人博客</title>
      <link>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Thu, 12 Mar 2020 23:21:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>&lt;p&gt;下面是windows用户hugo搭建博客的步骤：&lt;/p&gt;
&lt;h3 id=&#34;1-安装hugo&#34;&gt;1. 安装hugo&lt;/h3&gt;
&lt;p&gt;windows用户直接下载压缩包，解压缩之后把hugo的目录添加到环境变量&lt;/p&gt;
&lt;h3 id=&#34;2-创建本地站点&#34;&gt;2. 创建本地站点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hugo new site myblog&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-下载主题&#34;&gt;3. 下载主题&lt;/h3&gt;
&lt;p&gt;使用git下载一个默认主题 ananke&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd myblog&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置config.toml,把主题设置为ananke&lt;/p&gt;
&lt;p&gt;&lt;code&gt;echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-新建文章&#34;&gt;4. 新建文章&lt;/h3&gt;
&lt;p&gt;建议文章放在content/posts/&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hugo new content/posts/my_first_article.md&lt;/code&gt;
文章包含基本信息，其中draft参数是否设置为草稿&lt;/p&gt;
&lt;h3 id=&#34;5-运行本地服务器&#34;&gt;5. 运行本地服务器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hugo server -D&lt;/code&gt;
-D 参数可选，表示将草稿放上服务器&lt;/p&gt;
&lt;p&gt;至此，本地网站已生成，可以通过 &lt;code&gt;http://localhost:1313/&lt;/code&gt;进行访问
下面把网站部署到github&lt;/p&gt;
&lt;h3 id=&#34;6-部署到github&#34;&gt;6. 部署到github&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hugo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会生成一个public文件夹，待上传到github&lt;/p&gt;
&lt;p&gt;myblog仓库隐藏public,public建立git仓库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;echo -e &amp;quot;/public&amp;quot; &amp;gt;&amp;gt; .gitignore&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd public&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add .&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git commit -m test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在github建立新仓库。名为&lt;code&gt;yourname.github.io&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git remote add origin xxx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push -u origin master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大功告成，现在可以通过&lt;code&gt;yourname.github.io&lt;/code&gt;访问你的博客&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>开博大吉</title>
      <link>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
      <pubDate>Thu, 12 Mar 2020 17:01:17 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
      
        <description>&lt;p&gt;以后我会在这里记录前端学习的心得&lt;/p&gt;
&lt;p&gt;多做总结，才会进步&lt;/p&gt;
&lt;h1 id=&#34;好嗨哟&#34;&gt;好嗨哟&lt;/h1&gt;
</description>
      
    </item>
    
  </channel>
</rss>
